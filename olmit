#!/usr/bin/env python3
import os
import ollama
import json
from git import Repo, GitCommandError
from typing import List, Tuple, Dict, Any
from concurrent.futures import ThreadPoolExecutor, as_completed, TimeoutError
import time

# --- è¨­å®š ---
# å½¹å‰²ã”ã¨ã®ãƒ¢ãƒ‡ãƒ«è¨­å®šï¼ˆãƒ—ãƒ©ã‚¤ãƒãƒª -> ã‚»ã‚«ãƒ³ãƒ€ãƒªã®é †ã§è©¦è¡Œï¼‰
MODEL_ANALYST_PRIMARY = "qwen3-coder:480b-cloud"  # å„ªå…ˆãƒ¢ãƒ‡ãƒ«
MODEL_ANALYST_SECONDARY = "qwen2:7b"              # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ (ãƒ­ãƒ¼ã‚«ãƒ«)

MODEL_COMMITTER_PRIMARY = "qwen3-coder:480b-cloud"
MODEL_COMMITTER_SECONDARY = "qwen2:1.5b"          # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ (ãƒ­ãƒ¼ã‚«ãƒ«)

# ã‚µãƒ¼ãƒãƒ¼ã®URL
OLLAMA_URL = "http://localhost:11434"
# LLMã¸ã®åŒæ™‚ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ•° (Ollamaã‚µãƒ¼ãƒãƒ¼ã®æ€§èƒ½ã«åˆã‚ã›ã¦èª¿æ•´)
MAX_WORKERS = 2
# AIè¨­è¨ˆæ›¸/ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ (ã‚³ãƒŸãƒƒãƒˆå¯¾è±¡ã‹ã‚‰**å¿…ãšé™¤å¤–**ã™ã‚‹)
LOG_FILE = "auto_commit_log.json"
# ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã®æœ€å¤§åˆ¶é™æ™‚é–“ï¼ˆç§’ï¼‰ã€‚ã“ã‚Œã‚’è¶…ãˆã‚‹ã¨å®šå‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã‚³ãƒŸãƒƒãƒˆã™ã‚‹ã€‚
FILE_PROCESSING_TIMEOUT = 120
# ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚’è©¦è¡Œã™ã‚‹ä¸€èˆ¬çš„ãªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
COMMON_ENCODINGS = ["utf-8", "shift_jis", "euc_jp"]


# --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•° ---

def get_installed_models(client: ollama.Client) -> List[str]:
    """Ollamaã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ãƒ¢ãƒ‡ãƒ«ã®ãƒªã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹"""
    try:
        models = client.list()

        model_list: List[str] = []
        for m in models.get("models", []):
            if "name" in m:
                model_list.append(m["name"])
            elif "model" in m:
                model_list.append(m["model"])

        return model_list

    except Exception as e:
        error_msg = str(e)
        if "Connection refused" in error_msg or "Failed to connect" in error_msg:
            print(
                "ğŸš¨ **è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼**: Ollamaã‚µãƒ¼ãƒãƒ¼ã¸ã®æ¥ç¶šã«å¤±æ•—ã—ã¾ã—ãŸã€‚"
                "`ollama serve` ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
            )
        else:
            print(f"ğŸš¨ **äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼**: ãƒ¢ãƒ‡ãƒ«ãƒªã‚¹ãƒˆã®å–å¾—ä¸­ã«äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        return []


def check_and_pull_models(client: ollama.Client) -> None:
    """å¿…è¦ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ‡ãƒ«ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹"""
    required_secondary = [MODEL_ANALYST_SECONDARY, MODEL_COMMITTER_SECONDARY]
    installed = get_installed_models(client)

    # æ¥ç¶šè‡ªä½“ãŒæ­»ã‚“ã§ã„ã‚‹å ´åˆ
    if not installed and not getattr(client, "_session", None):
        exit(1)

    print("\n--- ğŸ§  LLMãƒ¢ãƒ‡ãƒ«ã®ç¢ºèª ---")

    all_secondary_ready = True
    for required_model in required_secondary:
        found = any(required_model in installed_name for installed_name in installed)

        if not found:
            print(f"âš ï¸ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ‡ãƒ« **{required_model}** ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚")
            print(f"   ã‚¢ãƒ‰ãƒã‚¤ã‚¹: ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã§ `ollama pull {required_model}` ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚")
            all_secondary_ready = False
        else:
            print(f"âœ… ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ‡ãƒ« **{required_model}** ã¯ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ã§ã™ã€‚")

    if not all_secondary_ready:
        print("\nâ›” é‡è¦ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ‡ãƒ«ãŒæƒã£ã¦ã„ã¾ã›ã‚“ã€‚ãƒ—ãƒ©ã‚¤ãƒãƒªãƒ¢ãƒ‡ãƒ«ãŒä½¿ãˆãªã„å ´åˆã€å‡¦ç†ãŒç¶™ç¶šã§ãã¾ã›ã‚“ã€‚")


def generate_message(
    client: ollama.Client,
    primary_model: str,
    secondary_model: str,
    prompt: str,
    file_path: str,
    task_name: str,
) -> str:
    """ãƒ—ãƒ©ã‚¤ãƒãƒªãƒ¢ãƒ‡ãƒ«ã‚’è©¦è¡Œã—ã€å¤±æ•—ã—ãŸå ´åˆã‚»ã‚«ãƒ³ãƒ€ãƒªãƒ¢ãƒ‡ãƒ«ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã™ã‚‹"""

    models_to_try = [primary_model, secondary_model]

    for i, model in enumerate(models_to_try):
        if i > 0:
            print(
                f"âš ï¸ **{models_to_try[0]}** ãŒå¤±æ•—ã—ãŸãŸã‚ã€"
                f"**ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯**ã¨ã—ã¦ **{model}** ã‚’è©¦è¡Œã—ã¾ã™ã€‚"
            )

        print(f"â³ **[{model}]** {file_path} ã® {task_name} ã‚’æ€è€ƒä¸­...", end="", flush=True)

        try:
            # LLM APIå‘¼ã³å‡ºã—
            response = client.chat(
                model=model,
                messages=[
                    {
                        "role": "system",
                        "content": "ã‚ãªãŸã¯ãƒ—ãƒ­ã®ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã§ã€ç°¡æ½”ã§æ­£ç¢ºãªèª¬æ˜ã€"
                                   "ã¾ãŸã¯çš„ç¢ºãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’æ—¥æœ¬èªã§è¡Œã„ã¾ã™ã€‚",
                    },
                    {"role": "user", "content": prompt},
                ],
                options={"temperature": 0.3},
            )
            print(" âœ… å®Œäº†")

            content = response.get("message", {}).get("content", "").strip()
            if not content:
                raise ValueError(f"LLM ({model}) ã‹ã‚‰ã®å¿œç­”å†…å®¹ãŒç©ºã§ã—ãŸã€‚")

            # LLMå‡ºåŠ›ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            content = content.replace("```json", "").replace("```", "").strip()
            content = "\n".join([line.strip() for line in content.splitlines() if line.strip()])

            return content

        except Exception as e:
            print(f" âŒ å¤±æ•— ({e.__class__.__name__})")
            if i == len(models_to_try) - 1:
                print(f"ğŸš¨ **LLMå¿œç­”ç”Ÿæˆã‚¨ãƒ©ãƒ¼**: å…¨ã¦ã®ãƒ¢ãƒ‡ãƒ«ã§ã®å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
                return "LLMå¿œç­”ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚"


def get_file_content(repo_path: str, file_path: str, is_untracked: bool) -> Tuple[str, str]:
    """ãƒ•ã‚¡ã‚¤ãƒ«ã®å·®åˆ†ã¾ãŸã¯å†…å®¹ã‚’å–å¾—ã™ã‚‹ï¼ˆæœªã‚¹ãƒ†ãƒ¼ã‚¸ / ã‚¹ãƒ†ãƒ¼ã‚¸æ¸ˆã¿ä¸¡æ–¹å¯¾å¿œï¼‰"""

    try:
        repo = Repo(repo_path)
    except Exception as e:
        return f"Gitãƒªãƒã‚¸ãƒˆãƒªã®å†åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}", "E"

    status: str = ""
    content: str = ""

    try:
        # HEAD ãŒæœ‰åŠ¹ã‹ã©ã†ã‹åˆ¤å®š
        has_head = True
        try:
            _ = repo.head.commit
        except Exception:
            has_head = False

        if is_untracked:
            status = "A"
        else:
            # æœªã‚¹ãƒ†ãƒ¼ã‚¸å·®åˆ†ï¼ˆindex vs working treeï¼‰
            diffs_wc = repo.index.diff(None)

            found_diff = False

            # ã¾ãšæœªã‚¹ãƒ†ãƒ¼ã‚¸ã‹ã‚‰æ¢ã™
            for diff_item in diffs_wc:
                if diff_item.a_path == file_path or diff_item.b_path == file_path:
                    status = diff_item.change_type
                    found_diff = True
                    break

            # HEAD ãŒã‚ã‚‹å ´åˆã ã‘ã‚¹ãƒ†ãƒ¼ã‚¸æ¸ˆã¿å·®åˆ†ã‚‚è¦‹ã‚‹
            if not found_diff and has_head:
                diffs_staged = repo.index.diff("HEAD")
                for diff_item in diffs_staged:
                    if diff_item.a_path == file_path or diff_item.b_path == file_path:
                        status = diff_item.change_type
                        found_diff = True
                        break

            # HEAD ç„¡ã—ï¼ˆåˆå›ã‚³ãƒŸãƒƒãƒˆå‰ï¼‰ã§ diff ã‹ã‚‰æ‹¾ãˆãªã‹ã£ãŸã‚‚ã®ã¯ã€Œè¿½åŠ (A)ã€æ‰±ã„
            if not found_diff and not has_head:
                status = "A"
                found_diff = True

            if not found_diff:
                status = "?"
                return f"ãƒ•ã‚¡ã‚¤ãƒ«: {file_path} ã®å¤‰æ›´ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", "E"

        if status == "D":
            content = f"ãƒ•ã‚¡ã‚¤ãƒ«: {file_path} ãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚"

        elif status == "A":
            full_path = os.path.join(repo.working_tree_dir, file_path)

            # è¤‡æ•°ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è©¦è¡Œ
            read_success = False
            for encoding in COMMON_ENCODINGS:
                try:
                    with open(full_path, "r", encoding=encoding) as f:
                        content = f.read()
                        read_success = True
                        break
                except UnicodeDecodeError:
                    continue
                except Exception as e:
                    return f"ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}", "E"

            if not read_success:
                return (
                    "ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: è¤‡æ•°ã®ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° "
                    f"({', '.join(COMMON_ENCODINGS)}) ã§ãƒ‡ã‚³ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚",
                    "E",
                )

        elif status == "M":
            try:
                # å·®åˆ†ã‚’å–å¾—ï¼ˆHEAD ã¨ã®å·®åˆ†ï¼‰
                if has_head:
                    content = repo.git.diff("HEAD", file_path)
                else:
                    # HEAD ç„¡ã—ãªã‚‰ã€ã¨ã‚Šã‚ãˆãšç¾è¡Œãƒ•ã‚¡ã‚¤ãƒ«ä¸¸ã”ã¨
                    full_path = os.path.join(repo.working_tree_dir, file_path)
                    with open(full_path, "r", encoding="utf-8", errors="ignore") as f:
                        content = f.read()
            except GitCommandError as e:
                return f"Git Diffã‚³ãƒãƒ³ãƒ‰ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e.stderr.strip()}", "E"

        elif status in ("R", "C"):  # Rename, Copy
            return (
                f"ãƒ•ã‚¡ã‚¤ãƒ«: {file_path} ã¯ãƒªãƒãƒ¼ãƒ /ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸã€‚è¤‡é›‘ãªå¤‰æ›´ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚",
                "E",
            )
        else:
            status = "?"
            return (
                f"ãƒ•ã‚¡ã‚¤ãƒ«: {file_path} ã¯è¤‡é›‘ãªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ ({status}) ã§ã™ã€‚æ‰‹å‹•ã§ã‚³ãƒŸãƒƒãƒˆã—ã¦ãã ã•ã„ã€‚",
                "E",
            )

        return content, status

    except Exception as e:
        return f"ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ä¸­ã«äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}", "E"


# éåŒæœŸå®Ÿè¡Œã‚¿ã‚¹ã‚¯
def process_file_and_generate_messages(
    client_host: str, repo_path: str, file_path: str, is_untracked: bool
) -> Dict[str, Any]:
    """å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã®å¤‰æ›´ã‚’è§£æã—ã€ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆã™ã‚‹ï¼ˆéåŒæœŸå®Ÿè¡Œå¯¾è±¡ï¼‰"""

    client = ollama.Client(host=client_host)

    result: Dict[str, Any] = {
        "file_path": file_path,
        "status": "",
        "diff_content": "",
        "analysis_message": None,
        "commit_message": None,
        "error_advice": None,
    }

    diff_content, status = get_file_content(repo_path, file_path, is_untracked)
    result["status"] = status
    result["diff_content"] = diff_content

    if status == "E":
        result["error_advice"] = f"ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹å–å¾—ã‚¨ãƒ©ãƒ¼: {diff_content}"
        return result

    # LLMã«ã‚ˆã‚‹å¤‰æ›´å†…å®¹ã®è§£èª¬ï¼ˆANALYSIS_MESSAGEï¼‰
    analysis_prompt = (
        "ä»¥ä¸‹ã®Gitã®å·®åˆ†/ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’åˆ†æã—ã€**å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«å**ã€"
        "**å¤‰æ›´ç¨®åˆ¥ (æ–°è¦è¿½åŠ /ä¿®æ­£/å‰Šé™¤)**ã€**å¤‰æ›´ã®ç›®çš„**ã€**ä¸»ãªå¤‰æ›´ç‚¹**ã‚’æ—¥æœ¬èªã§ç°¡æ½”ã«"
        "**ç®‡æ¡æ›¸ãã§è§£èª¬ã—ã¦ãã ã•ã„**ã€‚**å…¨ä½“ã®æ–‡å­—æ•°ã¯300æ–‡å­—ä»¥å†…**ã«æŠ‘ãˆã¦ãã ã•ã„ã€‚\n\n"
        f"å·®åˆ†/å†…å®¹:\n{diff_content}"
    )
    analysis_message = generate_message(
        client,
        MODEL_ANALYST_PRIMARY,
        MODEL_ANALYST_SECONDARY,
        analysis_prompt,
        file_path,
        "å†…å®¹è§£æ",
    )
    result["analysis_message"] = analysis_message

    if analysis_message == "LLMå¿œç­”ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚":
        result["error_advice"] = analysis_message
        return result

    # LLMã«ã‚ˆã‚‹ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ä½œæˆï¼ˆCOMMIT_MESSAGEï¼‰
    commit_prompt = (
        "ä»¥ä¸‹ã®æƒ…å ±ã«åŸºã¥ãã€Gitã®ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆ**ä¸€è¡Œç›®**ã¯**å³å¯†ã«50æ–‡å­—ä»¥å†…**ã®æ¦‚è¦ã€"
        "**äºŒè¡Œç›®ä»¥é™**ã¯è©³ç´°ãªèª¬æ˜ï¼‰ã‚’æ—¥æœ¬èªã§ä½œæˆã—ã¦ãã ã•ã„ã€‚"
        "**å¿œç­”å…¨ä½“ã«Markdownã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯è¨˜å·ï¼ˆ```ï¼‰ã¯ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„**ã€‚\n\n"
        f"ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {status} (A:è¿½åŠ , M:ä¿®æ­£, D:å‰Šé™¤)\n\nå¤‰æ›´è§£èª¬:\n{analysis_message}"
    )
    commit_message = generate_message(
        client,
        MODEL_COMMITTER_PRIMARY,
        MODEL_COMMITTER_SECONDARY,
        commit_prompt,
        file_path,
        "ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä½œæˆ",
    )
    result["commit_message"] = commit_message

    if commit_message == "LLMå¿œç­”ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚":
        result["error_advice"] = commit_message

    return result


# ãƒ­ã‚°æ›¸ãå‡ºã—é–¢æ•°
def write_log(repo_root: str, log_data: Dict[str, Any]) -> None:
    """AIè¨­è¨ˆæ›¸/ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãå‡ºã™"""
    log_path = os.path.join(repo_root, LOG_FILE)

    try:
        logs: Dict[str, Any] = {}
        if os.path.exists(log_path):
            with open(log_path, "r", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                except json.JSONDecodeError:
                    print(f"ğŸš¨ ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ« {LOG_FILE} ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ–°ã—ã„ãƒ­ã‚°ã§ä¸Šæ›¸ãã—ã¾ã™ã€‚")

        timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())

        logs[timestamp] = log_data

        with open(log_path, "w", encoding="utf-8") as f:
            json.dump(logs, f, ensure_ascii=False, indent=4)
        print(f"\nğŸ“ AIè¨­è¨ˆæ›¸/ãƒ­ã‚°ã‚’ãƒ•ã‚¡ã‚¤ãƒ« **{LOG_FILE}** ã«æ›¸ãè¾¼ã¿ã¾ã—ãŸã€‚")

    except Exception as e:
        print(f"\nğŸš¨ ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ« **{LOG_FILE}** ã®æ›¸ãè¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")


# ã‚¨ãƒ©ãƒ¼ã‚¢ãƒ‰ãƒã‚¤ã‚¹å°‚ç”¨ã®LLMå‘¼ã³å‡ºã—
def get_error_advice(client: ollama.Client, error_context: str) -> str:
    """ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆã™ã‚‹"""
    advice_prompt = (
        "ä»¥ä¸‹ã®å•é¡Œ/ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«Gitã®æ“ä½œã‚„ãƒ•ã‚¡ã‚¤ãƒ«ã®çŠ¶æ…‹ã«ã¤ã„ã¦ã€"
        "ç°¡æ½”ã§å…·ä½“çš„ãªæ—¥æœ¬èªã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’æä¾›ã—ã¦ãã ã•ã„ã€‚\n\n"
        f"å•é¡Œ: {error_context}"
    )

    try:
        response = client.chat(
            model=MODEL_COMMITTER_SECONDARY,
            messages=[
                {
                    "role": "system",
                    "content": "ã‚ãªãŸã¯ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†è€…ã§ã€ç™ºç”Ÿã—ãŸã‚¨ãƒ©ãƒ¼ã«å¯¾ã™ã‚‹å…·ä½“çš„ãª"
                               "è§£æ±ºç­–ã‚’æ—¥æœ¬èªã§æç¤ºã—ã¾ã™ã€‚",
                },
                {"role": "user", "content": advice_prompt},
            ],
            options={"temperature": 0.3},
        )
        advice = response.get("message", {}).get("content", "").strip()
        advice = advice.replace("```json", "").replace("```", "").strip()
        advice = "\n".join([line.strip() for line in advice.splitlines() if line.strip()])
        return advice if advice else "ï¼ˆLLMã«ã‚ˆã‚‹ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”ŸæˆãŒç©ºã§ã—ãŸï¼‰"
    except Exception:
        return "ï¼ˆLLMã«ã‚ˆã‚‹ã‚¢ãƒ‰ãƒã‚¤ã‚¹ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ­ãƒ¼ã‚«ãƒ«ãƒ¢ãƒ‡ãƒ«ãŒåˆ©ç”¨å¯èƒ½ã‹ç¢ºèªã—ã¦ãã ã•ã„ï¼‰"


# æœ€çµ‚çµæœã‚’æ•´å½¢ã—ã¦è¡¨ç¤ºã™ã‚‹é–¢æ•°
def display_summary(results: List[Dict[str, Any]]) -> None:
    """ã‚³ãƒŸãƒƒãƒˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¨ã‚¹ã‚­ãƒƒãƒ—ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã®çµæœã‚’ä¸€è¦§è¡¨ç¤ºã™ã‚‹"""
    committed = [r for r in results if r.get("commit_sha")]
    skipped = [r for r in results if not r.get("commit_sha") and r.get("file") != LOG_FILE]

    print("\n" + "=" * 80)
    print("=== ğŸŒŸ æœ€çµ‚ã‚³ãƒŸãƒƒãƒˆçµæœã‚µãƒãƒªãƒ¼ ğŸŒŸ ===")
    print("=" * 80)

    if committed:
        print(f"## âœ… ã‚³ãƒŸãƒƒãƒˆæˆåŠŸãƒ•ã‚¡ã‚¤ãƒ« ({len(committed)}ä»¶)")
        for r in committed:
            file_path = r["file"]
            commit_msg_summary = (
                r["messages"]["commit"].splitlines()[0] if r["messages"]["commit"] else "(ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãªã—)"
            )
            print(f"\n### ğŸ“„ {file_path} (SHA: {r['commit_sha']})")
            print("**å·®åˆ†ï¼ˆGit Diffã‹ã‚‰ã®å·®åˆ†ã‚’è¦ç´„ï¼‰:**")
            print(r["messages"]["analysis"] or "(AIè§£æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãªã—)")
            print("**ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸:**")
            print(f"> {commit_msg_summary}")
        print("-" * 40)
    else:
        print("## âœ… ã‚³ãƒŸãƒƒãƒˆæˆåŠŸãƒ•ã‚¡ã‚¤ãƒ« (0ä»¶)")
        print("ã‚³ãƒŸãƒƒãƒˆã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
        print("-" * 40)

    if skipped:
        print(f"\n## âŒ ã‚¹ã‚­ãƒƒãƒ—/ã‚¨ãƒ©ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ« ({len(skipped)}ä»¶)")
        for r in skipped:
            file_path = r["file"]
            error_reason = r["error"] or "(ã‚³ãƒŸãƒƒãƒˆæ“ä½œä¸­ã«ã‚¨ãƒ©ãƒ¼)"

            print(f"\n### âš ï¸ {file_path}")
            print("**âŒ å‡¦ç†å¤±æ•—/ã‚¹ã‚­ãƒƒãƒ—ç†ç”±:**")
            print(f"> {error_reason.splitlines()[0]}...")
            if r["messages"].get("commit"):
                print("**ğŸ’¬ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ¡ˆ (å‚è€ƒ):**")
                print(f"> {r['messages']['commit'].splitlines()[0]}")
        print("-" * 40)

    print("=" * 80)


def display_file_commit_detail(repo: Repo, client: ollama.Client, log_entry: Dict[str, Any]) -> bool:
    """å˜ä¸€ãƒ•ã‚¡ã‚¤ãƒ«ã®LLMçµæœè©³ç´°ã‚’è¡¨ç¤ºã—ã€ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ã¨å³æ™‚ã‚³ãƒŸãƒƒãƒˆã‚’å®Ÿè¡Œã™ã‚‹"""
    file_path = log_entry["file"]
    res = log_entry["messages"]
    status = log_entry["status"]

    print(f"\n### ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ«: {file_path} (ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {status}) ###")

    # ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆå¤±æ•—ã®å ´åˆ
    if log_entry.get("error") or res.get("commit") in ("LLMå¿œç­”ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ.", None, ""):

        error_msg = log_entry.get("error") or "LLMãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆå¤±æ•—"
        print("ğŸš¨ **å‡¦ç†ã‚¹ã‚­ãƒƒãƒ—**:")
        print(f"> {error_msg}")

        # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®å ´åˆã€å®šå‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚³ãƒŸãƒƒãƒˆã®ææ¡ˆã‚’è¡Œã†
        if "LLMå‡¦ç†ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ" in error_msg:
            # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã¯ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç”Ÿæˆã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã“ã“ã§ã‚³ãƒŸãƒƒãƒˆã«é€²ã‚€
            # ï¼ˆã“ã®é–¢æ•°ã¯å…ƒã€…ã€ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯Falseã‚’è¿”ã™è¨­è¨ˆã ãŒã€ä»Šå›ã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã¯åˆ¥çµŒè·¯ã§ã‚³ãƒŸãƒƒãƒˆæˆåŠŸã•ã›ãŸã„ï¼‰
            pass  # å¾Œç¶šã®ã‚³ãƒŸãƒƒãƒˆå®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯ã«é€²ã¾ã›ã‚‹

        # LLMå¿œç­”å¤±æ•—ä»¥å¤–ã®å ´åˆã«ã®ã¿ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆ
        elif "LLMå¿œç­”ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ" not in error_msg:
            advice = get_error_advice(client, error_msg)
            print(f"ğŸ’¡ LLMã‹ã‚‰ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹:\n{advice}")
            return False  # å¤±æ•—

    # æ­£å¸¸ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç”Ÿæˆã•ã‚ŒãŸå ´åˆã€ã¾ãŸã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã‚ã‚‹å ´åˆ

    print("\n**å†…å®¹ (å‡¦ç†å†…å®¹è¦ç´„)**")
    print(res["analysis"])

    print("**å·®åˆ†ï¼ˆGit Diffã‹ã‚‰ã®å·®åˆ†ã‚’è¦ç´„ï¼‰**")
    diff_content = log_entry.get("diff_content", "ï¼ˆå·®åˆ†å†…å®¹ã®å–å¾—ã«å¤±æ•—ï¼‰")

    truncated_diff = diff_content[:500]
    suffix = "\n... (ä»¥ä¸‹çœç•¥)\n" if len(diff_content) > 500 else "\n"

    print(f"```diff\n{truncated_diff}{suffix}```")

    print("**ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸**")
    print("---")
    print(res["commit"])
    print("---")

    # --- ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ï¼†å³æ™‚ã‚³ãƒŸãƒƒãƒˆå®Ÿè¡Œ ---
    try:
        # 1. ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°
        if status == "D":
            # å‰Šé™¤ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯ git rm ç›¸å½“ã§ index ã‹ã‚‰å‰Šé™¤
            repo.git.rm(file_path)
            print(f"å‰Šé™¤ãƒ•ã‚¡ã‚¤ãƒ« {file_path} ã‚’ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ã—ã¾ã—ãŸ (git rm ç›¸å½“)")
        else:
            # è¿½åŠ ãƒ»ä¿®æ­£ (A/M ãªã©) ã¯ add ã§OK
            repo.index.add([file_path])
            print("âœ… **ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°æˆåŠŸ**")

        # 2. ã‚³ãƒŸãƒƒãƒˆå®Ÿè¡Œ
        commit_message = res["commit"].strip()
        if not commit_message:
            raise ValueError("LLM/ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒç©ºã®ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆã—ã¾ã—ãŸã€‚")

        new_commit = repo.index.commit(commit_message)

        log_entry["commit_sha"] = new_commit.hexsha[:8]

        if "TIMEOUT_FALLBACK" in log_entry["analyzed_by"]:
            print(
                "âš ï¸ **ã‚³ãƒŸãƒƒãƒˆå®Œäº†ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰**: "
                f"ãƒ•ã‚¡ã‚¤ãƒ« {file_path} ã‚’å®šå‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã‚³ãƒŸãƒƒãƒˆã—ã¾ã—ãŸã€‚SHA: {new_commit.hexsha[:8]}"
            )
        else:
            print(
                "ğŸ‰ **ã‚³ãƒŸãƒƒãƒˆå®Œäº†**: "
                f"ãƒ•ã‚¡ã‚¤ãƒ« {file_path} ã‚’å€‹åˆ¥ã«ã‚³ãƒŸãƒƒãƒˆã—ã¾ã—ãŸã€‚SHA: {new_commit.hexsha[:8]}"
            )

        return True  # ã‚³ãƒŸãƒƒãƒˆæˆåŠŸ

    except GitCommandError as e:
        error_detail = e.stderr.strip()
        print(f"ğŸš¨ **Gitæ“ä½œã‚¨ãƒ©ãƒ¼**: {file_path} ã®ã‚³ãƒŸãƒƒãƒˆã«å¤±æ•—: {error_detail}")
        log_entry["error"] = f"Git Commit Failed: {error_detail}"

        if "hook failed" in error_detail or "pre-commit" in error_detail:
            print(
                "âš ï¸ **é‡è¦**: ã‚³ãƒŸãƒƒãƒˆæ“ä½œä¸­ã« Gitãƒ•ãƒƒã‚¯ãŒå¤±æ•—ã—ã¾ã—ãŸã€‚"
                "ãƒ•ãƒƒã‚¯ (ä¾‹: pre-commit) ã®å‡ºåŠ›ãŒã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å«ã¾ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚"
            )

        # ã‚³ãƒŸãƒƒãƒˆã«å¤±æ•—ã—ãŸå ´åˆã€ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ã‚’è§£é™¤
        try:
            repo.index.reset([file_path], working_tree=False)
            print(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ« {file_path} ã®ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚")
        except Exception:
            pass

        advice = get_error_advice(client, log_entry["error"])
        print(f"ğŸ’¡ LLMã‹ã‚‰ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹:\n{advice}")
        return False  # ã‚³ãƒŸãƒƒãƒˆå¤±æ•—

    except Exception as e:
        error_message = str(e)
        print(f"ğŸš¨ **äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼**: {file_path} ã®ã‚³ãƒŸãƒƒãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ: {error_message}")
        log_entry["error"] = f"Unexpected Error: {error_message}"

        # äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ã®å ´åˆã‚‚ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ã‚’è§£é™¤
        try:
            repo.index.reset([file_path], working_tree=False)
            print(f"âŒ ãƒ•ã‚¡ã‚¤ãƒ« {file_path} ã®ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ã‚’è§£é™¤ã—ã¾ã—ãŸã€‚")
        except Exception:
            pass

        advice = get_error_advice(client, log_entry["error"])
        print(f"ğŸ’¡ LLMã‹ã‚‰ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹:\n{advice}")
        return False  # ã‚³ãƒŸãƒƒãƒˆå¤±æ•—


def main() -> None:
    """ãƒ¡ã‚¤ãƒ³å‡¦ç†"""
    print("--- ğŸ¤– Ollama Git Auto-Commit Tool ğŸš€ ---")

    # 1. ãƒªãƒã‚¸ãƒˆãƒªã®ç¢ºèª
    try:
        # è¦ªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚‚å«ã‚ã¦ .git ã‚’æ¢ç´¢
        repo = Repo(os.getcwd(), search_parent_directories=True)
        repo_root = repo.working_tree_dir
        print(f"âœ… Gitãƒªãƒã‚¸ãƒˆãƒªã‚’ç¢ºèªã—ã¾ã—ãŸã€‚ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª: {repo_root}")
    except GitCommandError:
        print("ğŸš¨ ã‚¨ãƒ©ãƒ¼: `.git` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚")
        return
    except Exception as e:
        print(f"ğŸš¨ äºˆæœŸã›ã¬ãƒªãƒã‚¸ãƒˆãƒªåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")
        return

    # HEAD ãŒå­˜åœ¨ã™ã‚‹ã‹ï¼ˆ= 1å›ä»¥ä¸Šã‚³ãƒŸãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹ã‹ï¼‰ã‚’åˆ¤å®š
    has_head = True
    try:
        _ = repo.head.commit
    except Exception:
        has_head = False

    # 2. Ollamaã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ãƒ¢ãƒ‡ãƒ«ã®ãƒã‚§ãƒƒã‚¯
    client = ollama.Client(host=OLLAMA_URL)
    check_and_pull_models(client)

    # â˜… ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãƒªãƒã‚¸ãƒˆãƒªãƒ«ãƒ¼ãƒˆã®é–¢ä¿‚ã‚’å…ˆã«è¨ˆç®—
    cwd = os.getcwd()
    try:
        rel_cwd = os.path.relpath(cwd, repo_root)  # ä¾‹: "ollajio"
    except ValueError:
        # ä½•ã‹ãŠã‹ã—ãã¦ã‚‚ã€ã¨ã‚Šã‚ãˆãšãƒ«ãƒ¼ãƒˆæ‰±ã„ã«ã—ã¦ãŠã
        rel_cwd = "."

    # 3. å‡¦ç†å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã®ä½œæˆ
    # æœªã‚¹ãƒ†ãƒ¼ã‚¸ã®å·®åˆ†ï¼ˆindex vs working treeï¼‰
    unstaged_diffs = repo.index.diff(None)

    # ã‚¹ãƒ†ãƒ¼ã‚¸æ¸ˆã¿ã®å·®åˆ†
    if has_head:
        # é€šå¸¸: HEAD ã¨ index ã®å·®åˆ†
        staged_diffs = repo.index.diff("HEAD")
    else:
        # åˆå›ã‚³ãƒŸãƒƒãƒˆå‰: HEAD ãŒç„¡ã„ã®ã§ç©º
        staged_diffs = []

    # æœªè¿½è·¡ãƒ•ã‚¡ã‚¤ãƒ«
    untracked_files = repo.untracked_files

    target_files: Dict[str, bool] = {}

    # æœªã‚¹ãƒ†ãƒ¼ã‚¸ã®å¤‰æ›´
    for diff in unstaged_diffs:
        if diff.change_type in ("A", "M", "D", "T"):
            file = diff.a_path or diff.b_path
            if not repo.ignored(file) and file != LOG_FILE:
                target_files[file] = False  # is_untracked = False

    # ã‚¹ãƒ†ãƒ¼ã‚¸æ¸ˆã¿ã®å¤‰æ›´ï¼ˆæœªã‚¹ãƒ†ãƒ¼ã‚¸ã¨é‡è¤‡ã—ãªã„ã‚‚ã®ï¼‰
    for diff in staged_diffs:
        if diff.change_type in ("A", "M", "D", "T"):
            file = diff.a_path or diff.b_path
            if not repo.ignored(file) and file != LOG_FILE:
                target_files.setdefault(file, False)

    # åˆå›ã‚³ãƒŸãƒƒãƒˆå‰: index ã«è¼‰ã£ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å…¨éƒ¨ã€Œè¿½åŠ (A)ã€ã¨ã—ã¦æ‰±ã†
    if not has_head:
        for (path, stage), entry in repo.index.entries.items():
            if stage != 0:
                continue
            if not repo.ignored(path) and path != LOG_FILE:
                target_files.setdefault(path, False)

    # æœªè¿½è·¡ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆâ˜…ã‚«ãƒ¬ãƒ³ãƒˆé…ä¸‹ã ã‘è³ªå•ã™ã‚‹ï¼‰
    for file in untracked_files:
        if repo.ignored(file) or file == LOG_FILE:
            continue

        # å®Ÿè¡Œä¸­ã‚¹ã‚¯ãƒªãƒ—ãƒˆè‡ªèº«ã¯ç„¡æ¡ä»¶ã‚¹ã‚­ãƒƒãƒ—
        if file == os.path.basename(__file__):
            continue

        # ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªé…ä¸‹ã ã‘ã«é™å®š
        if rel_cwd != ".":
            prefix = rel_cwd.rstrip("/") + "/"
            # ä¾‹:
            #   rel_cwd = "ollajio"
            #   file    = "ollajio/main.py" â†’ OK
            #   file    = "main.py"        â†’ ã‚¹ã‚­ãƒƒãƒ—
            #   file    = "kennybot/..."   â†’ ã‚¹ã‚­ãƒƒãƒ—
            if not (file == rel_cwd or file.startswith(prefix)):
                continue

        # ã“ã“ã¾ã§æ¥ãŸ untracked ã ã‘è³ªå•
        answer = input(
            f"\nâš ï¸  æœªè¿½è·¡ãƒ•ã‚¡ã‚¤ãƒ« **{file}** ã‚’ã‚³ãƒŸãƒƒãƒˆå¯¾è±¡ã«å«ã‚ã¾ã™ã‹ï¼Ÿ (y/n): "
        ).strip().lower()
        if answer == "y":
            target_files[file] = True  # is_untracked = True

    # â˜… è¿½åŠ ã®ä¿é™º: target_files ã‚’ã‚«ãƒ¬ãƒ³ãƒˆé…ä¸‹ã ã‘ã«çµã‚‹
    if rel_cwd != ".":
        prefix = rel_cwd.rstrip("/") + "/"
        filtered: Dict[str, bool] = {
            path: flag
            for path, flag in target_files.items()
            if path == rel_cwd or path.startswith(prefix)
        }
        if not filtered:
            print(f"âœ… ã‚«ãƒ¬ãƒ³ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªé…ä¸‹ ({rel_cwd}) ã®å¤‰æ›´ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å‡¦ç†ã‚’çµ‚äº†ã—ã¾ã™ã€‚")
            return
        target_files = filtered

    if not target_files:
        print("âœ… å‡¦ç†å¯¾è±¡ã®å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€‚å‡¦ç†ã‚’çµ‚äº†ã—ã¾ã™ã€‚")
        return

    print("\n--- ğŸ” å‡¦ç†å¯¾è±¡ã®å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆ ---")
    for path, is_untracked in target_files.items():
        flag = "untracked" if is_untracked else "tracked"
        print(f"- {path} ({flag})")

    # 4. LLMä¸¦åˆ—å‡¦ç†ã«ã‚ˆã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆ
    all_results: Dict[str, Dict[str, Any]] = {}

    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        futures = {
            executor.submit(
                process_file_and_generate_messages, OLLAMA_URL, repo_root, file_path, is_untracked
            ): file_path
            for file_path, is_untracked in target_files.items()
        }

        print(f"\n--- âš¡ï¸ LLMä¸¦åˆ—å‡¦ç†é–‹å§‹ (æœ€å¤§ {MAX_WORKERS} ã‚¹ãƒ¬ãƒƒãƒ‰) ---")

        for future in as_completed(futures):
            file_path = futures[future]
            try:
                # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
                result = future.result(timeout=FILE_PROCESSING_TIMEOUT)
                all_results[file_path] = result
            except TimeoutError:
                # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
                print(
                    f"\nğŸš¨ **ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ**: ãƒ•ã‚¡ã‚¤ãƒ« {file_path} ã® LLM å‡¦ç†ãŒ "
                    f"{FILE_PROCESSING_TIMEOUT} ç§’ã‚’è¶…éã—ã¾ã—ãŸã€‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚"
                )

                _, status = get_file_content(repo_root, file_path, target_files[file_path])

                commit_msg = f"{file_path}: å¤§è¦æ¨¡ãƒ•ã‚¡ã‚¤ãƒ«ã®{status}ã‚’è‡ªå‹•ã‚³ãƒŸãƒƒãƒˆ (LLMã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ)"
                analysis_msg = (
                    "LLMå‡¦ç†ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸãŸã‚ã€ãƒ•ã‚¡ã‚¤ãƒ«åã¨çŠ¶æ…‹ã«åŸºã¥ã„ã¦"
                    "å®šå‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã‚³ãƒŸãƒƒãƒˆã—ã¾ã™ã€‚"
                    f"ãƒ•ã‚¡ã‚¤ãƒ«ã®çŠ¶æ…‹: {status}"
                )

                all_results[file_path] = {
                    "file_path": file_path,
                    "status": status,
                    "diff_content": "ï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã«ã‚ˆã‚Šè©³ç´°å·®åˆ†å–å¾—ã‚¹ã‚­ãƒƒãƒ—ï¼‰",
                    "analysis_message": analysis_msg,
                    "commit_message": commit_msg,
                    "error_advice": f"LLMå‡¦ç†ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ ({FILE_PROCESSING_TIMEOUT}ç§’)ã€‚å®šå‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆã—ã¾ã—ãŸã€‚",
                }

            except Exception as e:
                print(
                    f"ğŸš¨ **ã‚¹ãƒ¬ãƒƒãƒ‰å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼**: "
                    f"ãƒ•ã‚¡ã‚¤ãƒ« {file_path} ã®å‡¦ç†ä¸­ã«äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}"
                )
                all_results[file_path] = {
                    "file_path": file_path,
                    "error_advice": f"ã‚¹ãƒ¬ãƒƒãƒ‰å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼: {e}",
                }

    # 5. LLMå‡¦ç†çµæœã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤ºã¨å³æ™‚ã‚³ãƒŸãƒƒãƒˆ
    log_data: Dict[str, Any] = {"processed_files": []}
    committed_count = 0

    print("\n" + "=" * 80)
    print("=== âœ… LLMå‡¦ç†çµæœã¨å³æ™‚å€‹åˆ¥ã‚³ãƒŸãƒƒãƒˆå®Ÿè¡Œ ===")
    print("=" * 80)

    for file_path, is_untracked in target_files.items():
        res = all_results.get(file_path)

        if not res:
            continue

        log_entry: Dict[str, Any] = {
            "file": file_path,
            "status": res.get("status", "N/A"),
            "analyzed_by": (
                "TIMEOUT_FALLBACK"
                if res.get("error_advice") and "LLMå‡¦ç†ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ" in res["error_advice"]
                else MODEL_ANALYST_PRIMARY
            ),
            "commit_msg_by": (
                "TIMEOUT_FALLBACK"
                if res.get("error_advice") and "LLMå‡¦ç†ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ" in res["error_advice"]
                else MODEL_COMMITTER_PRIMARY
            ),
            "commit_sha": None,
            "messages": {
                "analysis": res.get("analysis_message"),
                "commit": res.get("commit_message"),
            },
            "diff_content": res.get("diff_content"),
            "error": res.get("error_advice"),
        }

        if display_file_commit_detail(repo, client, log_entry):
            committed_count += 1

        # ãƒ­ã‚°ã«ã¯ diff_content ã¯é‡ã„ã®ã§æ¶ˆã—ã¦ä¿å­˜
        if "diff_content" in log_entry:
            del log_entry["diff_content"]

        log_data["processed_files"].append(log_entry)

        print("-" * 40)

    # 6. æœ€çµ‚çµæœã®ä¸€è¦§è¡¨ç¤º
    display_summary(log_data["processed_files"])

    print(f"\nğŸ **åˆè¨ˆ**: {committed_count} ä»¶ã®å¤‰æ›´ãŒã‚³ãƒŸãƒƒãƒˆã•ã‚Œã¾ã—ãŸã€‚")

    # 7. ãƒ­ã‚°æ›¸ãå‡ºã—
    write_log(repo_root, log_data)

    # 8. ãƒ—ãƒƒã‚·ãƒ¥ç¢ºèª
    if committed_count > 0:
        answer = input("\nğŸš€ ãƒªãƒ¢ãƒ¼ãƒˆãƒªãƒã‚¸ãƒˆãƒªã«ä»Šã™ããƒ—ãƒƒã‚·ãƒ¥ã—ã¾ã™ã‹ï¼Ÿ (y/n): ").strip().lower()
        if answer == "y":
            try:
                origin = repo.remotes.origin
                print("ğŸ“¤ git push origin ã‚’å®Ÿè¡Œä¸­...")
                origin.push()
                print("âœ… ãƒªãƒ¢ãƒ¼ãƒˆã¸ã®ãƒ—ãƒƒã‚·ãƒ¥ãŒå®Œäº†ã—ã¾ã—ãŸã€‚")
            except Exception as e:
                print(f"ğŸš¨ ãƒªãƒ¢ãƒ¼ãƒˆã¸ã®ãƒ—ãƒƒã‚·ãƒ¥ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        else:
            print("â„¹ï¸ ä»Šå›ã®ã‚³ãƒŸãƒƒãƒˆã¯ãƒ­ãƒ¼ã‚«ãƒ«ã®ã¿ã«ä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(
            "\nâ›” Ctrl+C ã«ã‚ˆã‚Šå‡¦ç†ã‚’ä¸­æ–­ã—ã¾ã—ãŸã€‚"
            "ä¸­é€”åŠç«¯ãªã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ãŒç„¡ã„ã‹ `git status` ã§ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
        )
